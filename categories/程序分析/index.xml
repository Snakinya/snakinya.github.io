<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>程序分析 on Snakinya-明烛天南</title>
    <link>https://www.snakin.top/categories/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 程序分析 on Snakinya-明烛天南</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Mon, 01 Jan 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.snakin.top/categories/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>南大软分实验 ｜ 01 活跃变量分析和迭代求解器</title>
      <link>https://www.snakin.top/posts/01-assignment1/</link>
      <pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://www.snakin.top/posts/01-assignment1/</guid>
      <description>&lt;h2 id=&#34;活跃变量分析与迭代求解器&#34;&gt;活跃变量分析与迭代求解器&lt;/h2&gt;&#xA;&lt;p&gt;在此之前我们先回顾理解一下概念&lt;/p&gt;&#xA;&lt;p&gt;&lt;img alt=&#34;截屏2023-08-25 11.53.05&#34; src=&#34;https://cosmoslin.oss-cn-chengdu.aliyuncs.com/img2/%E6%88%AA%E5%B1%8F2023-08-25%2011.53.05.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;也就是说，判断一个变量是否存活，我们关注两个点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;变量在OUT[B]已经存活，并且在B中没有被重定义&lt;/li&gt;&#xA;&lt;li&gt;变量在OUT[B]已经存活，在B中被重定义之前使用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;由于算法是backward分析，可能不太好理解。我们转换思维，如果正向来看，我们的目标是判断&lt;code&gt;v=3&lt;/code&gt;中的变量3是否还会在后续被使用，那么前面所提到的两个点就很好理解了。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img alt=&#34;截屏2023-08-25 12.02.39&#34; src=&#34;https://cosmoslin.oss-cn-chengdu.aliyuncs.com/img2/%E6%88%AA%E5%B1%8F2023-08-25%2012.02.39.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img alt=&#34;image-20211101205624301&#34; src=&#34;https://cosmoslin.oss-cn-chengdu.aliyuncs.com/img2/image-20211101205624301.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Solver.java&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff5c57&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#9aedfe&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#57c7ff&#34;&gt;initializeBackward&lt;/span&gt;(CFG&lt;span style=&#34;color:#ff6ac1&#34;&gt;&amp;lt;&lt;/span&gt;Node&lt;span style=&#34;color:#ff6ac1&#34;&gt;&amp;gt;&lt;/span&gt; cfg, DataflowResult&lt;span style=&#34;color:#ff6ac1&#34;&gt;&amp;lt;&lt;/span&gt;Node, Fact&lt;span style=&#34;color:#ff6ac1&#34;&gt;&amp;gt;&lt;/span&gt; result) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#78787e&#34;&gt;// 初始化EXIT节点&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        result.&lt;span style=&#34;color:#57c7ff&#34;&gt;setInFact&lt;/span&gt;(cfg.&lt;span style=&#34;color:#57c7ff&#34;&gt;getExit&lt;/span&gt;(), analysis.&lt;span style=&#34;color:#57c7ff&#34;&gt;newBoundaryFact&lt;/span&gt;(cfg));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#78787e&#34;&gt;// 遍历节点，初始化INFACT和OUTFACT&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff6ac1&#34;&gt;for&lt;/span&gt; (Node node : cfg) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ff6ac1&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#ff6ac1&#34;&gt;!&lt;/span&gt;node.&lt;span style=&#34;color:#57c7ff&#34;&gt;equals&lt;/span&gt;(cfg.&lt;span style=&#34;color:#57c7ff&#34;&gt;getExit&lt;/span&gt;())) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                result.&lt;span style=&#34;color:#57c7ff&#34;&gt;setInFact&lt;/span&gt;(node, analysis.&lt;span style=&#34;color:#57c7ff&#34;&gt;newInitialFact&lt;/span&gt;());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                result.&lt;span style=&#34;color:#57c7ff&#34;&gt;setOutFact&lt;/span&gt;(node, analysis.&lt;span style=&#34;color:#57c7ff&#34;&gt;newInitialFact&lt;/span&gt;());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>南大软分笔记 ｜ 02 Intermediate Representation（IR）</title>
      <link>https://www.snakin.top/posts/02-intermediate-representation/</link>
      <pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://www.snakin.top/posts/02-intermediate-representation/</guid>
      <description>&lt;h2 id=&#34;intermediate-representationir&#34;&gt;Intermediate Representation（IR）&lt;/h2&gt;&#xA;&lt;h3 id=&#34;compliers-and-static-analyzers&#34;&gt;Compliers and static analyzers&lt;/h3&gt;&#xA;&lt;p&gt;编译过程:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;source code&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;↓↓↓&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;scanner(lexical analysis 词法分析)---&amp;gt;regular expression&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;↓↓↓ ---&amp;gt;Tokens&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Parser(Syntax Analysis 语法分析)---&amp;gt;context-free grammar上下文不敏感语法&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;↓↓↓ ---&amp;gt;AST 抽象语法树&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Type Checker 类型检查(Semantic Analysis 语义分析)---&amp;gt;attribute grammar &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;↓↓↓ ---&amp;gt; Decorated AST&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Translator&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;↓↓↓ ---&amp;gt;IR ---&amp;gt;Static Analysis&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Code Generator&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;↓↓↓&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;machine code&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;image-20230221125911472&#34; src=&#34;https://cosmoslin.oss-cn-chengdu.aliyuncs.com/img2/image-20230221125911472.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;编译器将源代码（Source code） 转换为机器代码（Machine Code）。其中的流程框架是：&lt;/p&gt;</description>
    </item>
    <item>
      <title>南大软分笔记 ｜ 03 Data Flow Analysis I</title>
      <link>https://www.snakin.top/posts/03-data-flow-analysis-i/</link>
      <pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://www.snakin.top/posts/03-data-flow-analysis-i/</guid>
      <description>&lt;h2 id=&#34;data-flow-analysis-i&#34;&gt;Data Flow Analysis I&lt;/h2&gt;&#xA;&lt;h3 id=&#34;overview-of-data-flow-analysis&#34;&gt;Overview of Data Flow Analysis&lt;/h3&gt;&#xA;&lt;p&gt;核心：how data flows on CFG?&#xA;展开：&#xA;how &lt;strong&gt;application-specific data&lt;/strong&gt; &amp;ndash;&amp;gt; abstraction&#xA;&lt;strong&gt;flows&lt;/strong&gt; through the &amp;ndash;&amp;gt;safe approximation&#xA;&lt;strong&gt;nodes&lt;/strong&gt;(BBs/statements) and &amp;ndash;&amp;gt;transfer function&#xA;&lt;strong&gt;edges&lt;/strong&gt;(control flows) of &amp;ndash;&amp;gt;control-flow handling&#xA;&lt;strong&gt;CFG&lt;/strong&gt;(a program)?&#xA;对于大多数静态分析来讲都是may analysis：&#xA;may analysis:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;outputs information that may be true(over-approximation)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;must analysis:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;outputs information that must be true(under-approximation)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Over-and under-approximations are &lt;strong&gt;both for safety of analysis&lt;/strong&gt;&#xA;about safe approximation ：&#xA;may analysis：safe = over&#xA;must analysis: safe = under&#xA;不同的数据流分析，有着不同的data abstraction, flow safe-approximation策略，transfer functions&amp;amp;control-flow handlings。&lt;/p&gt;</description>
    </item>
    <item>
      <title>南大软分笔记 ｜ 01 Course Introduction</title>
      <link>https://www.snakin.top/posts/01-introduction/</link>
      <pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://www.snakin.top/posts/01-introduction/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img alt=&#34;image-20230220082540547&#34; src=&#34;https://cosmoslin.oss-cn-chengdu.aliyuncs.com/img2/image-20230220082540547.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;why-we-need-static-analysis&#34;&gt;Why we need static analysis&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;reliability&lt;/li&gt;&#xA;&lt;li&gt;security&lt;/li&gt;&#xA;&lt;li&gt;compiler optimization(编译优化)&lt;/li&gt;&#xA;&lt;li&gt;program understanding&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;static-analysis&#34;&gt;Static Analysis&lt;/h3&gt;&#xA;&lt;p&gt;Static analysis analyzes a program P to reason about its behaviors and determines whether it satisfies some properties before runnning P.&lt;/p&gt;&#xA;&lt;p&gt;ps.静态+运行前分析&lt;/p&gt;&#xA;&lt;h3 id=&#34;useful-static-analysis&#34;&gt;Useful static analysis&lt;/h3&gt;&#xA;&lt;p&gt;mostly compromising completensee:Sound(overapproximate) but not fully-precise static analysis.&lt;/p&gt;&#xA;&lt;p&gt;保证全面性而可以损失精度&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Soundness(全面) is critical to a collection of important(static-analysis) applications such as compiler optimization and program verification.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
