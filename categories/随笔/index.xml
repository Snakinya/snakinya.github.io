<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>随笔 on Snakinya-明烛天南</title>
    <link>https://www.snakin.top/categories/%E9%9A%8F%E7%AC%94/</link>
    <description>Recent content in 随笔 on Snakinya-明烛天南</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Tue, 24 Jun 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.snakin.top/categories/%E9%9A%8F%E7%AC%94/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何在计算机应用领域寻找研究想法？</title>
      <link>https://www.snakin.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BAidea/</link>
      <pubDate>Tue, 24 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://www.snakin.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BAidea/</guid>
      <description>&lt;p&gt;多年以来，我指导并与十几位博士生合作，在这个过程中发现了一些常见的问题，这些问题阻碍了他们在研究中取得更好的进展。作为一名博士生导师，在本文中我将尝试给予计算机科学领域的学生一些指导建议。我的研究领域是网络安全，因此从事这一特定领域的学生可能会发现本文所给出的事例与他们更为相关（但也应该推广到其他实用性的领域，比如网络、系统和体系结构方向）。本文的观点大多是基于个人经验，因此可能会有失偏颇。尽管如此，我还是希望它能够对一些研究人员有用。对于那些在攻读博士学位之前从未做过任何研究的人来说，可能考虑从哪里入手研究都令人害怕。关于这一点存在两种情况：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;你有幸（或不幸）身处在一个工作超级高效的团队，有很多想法向你抛来——当你与青年教师一起工作时，这种情况经常发生（当然也有例外）。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;你身处在一个研究体系非常成熟的团队，你的导师不再给学生提供具体的研究思路。相反，他们可能会做的是给出一个非常高水平的方向，连同几篇相关的论文。这就是你脑洞出一个研究思路所能用到的全部内容。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;如果你属于第一类，那么你的第一个研究项目从获得、推进到完成的整个过程显然会是令人满意的，除非你并没有真正地从头至尾完成整个研究过程。事实上，在我看来，直接接受别人提供的研究想法是在逃避一个研究项目中最困难的一步——想出一个好的研究思路。凡事都有取舍，你确实能够更早地发表论文，而且可能根据你的导师（或者博士后亦或高年级研究生）选定的思路发表了一篇非常优秀的论文。但是，你失去了训练自己独立寻找研究思路的机会，而这是一个博士所必备的重要技能。作为一个导师，我也会觉得内疚，例如，我完成了发现漏洞过程中的困难部分，然后让学生执行其余内容。&lt;/p&gt;&#xA;&lt;p&gt;如果你属于第二种类型，则可能是成败参半的情况。要么你想出了一个好思路去执行，要么浪费了攻读博士学位生涯的头一两年，意识到这个思路没有任何用处然后决定放弃。我读博士的时候，目睹了第二种类型的博士生大约有一半选择退学。在上述任何一种类型的团队中（或介于两者之间的类型），你都应该尽早开始训练自己寻找研究思路的能力。否则，我认为这会是一个很大的缺陷，并可能在未来毕业后对你造成很大的影响，例如，作为学术界的教授或工业界的研究员，在独立领导研究项目时你可能会进行得很艰难。&lt;/p&gt;&#xA;&lt;p&gt;下面是我觉得很有用的一些小贴士。&lt;/p&gt;&#xA;&lt;h2 id=&#34;学会阅读论文培养自己的兴趣&#34;&gt;学会阅读论文，培养自己的兴趣&lt;/h2&gt;&#xA;&lt;p&gt;思路不是突然冒出来的。产生新思路最常见的方法之一是阅读其他论文并获得灵感。需要特别关注相关的研究课程，在那里你将开始阅读大量的论文。同时，你也需要写论文阅读笔记来表达你的观点、意见和任何有建设性的想法。最初，每周每节课读3~4篇论文是有压力的（我还是学生时在同一学期上过两节这样的课），但要坚持住。一个常见的误区是：你必须理解一篇论文的全部技术细节，才算完成论文阅读。不，那既不是主要目标，也不是在有效利用你的时间！在这样的课程中，欣赏和批判研究想法是一个学习的过程，例如，一篇论文为什么是好的或坏的？是什么使得一篇论文吸引人？你不必阅读论文的每一处细节来回答这些问题。关于如何阅读论文，其实有很多很有帮助的文章。例如，S.Keshav写的《如何阅读论文》。&lt;/p&gt;&#xA;&lt;p&gt;更重要的是，找到你最感兴趣的论文类型，多问问自己为什么。以网络安全领域为例，其涵盖的子领域十分广泛，甚至我都可能无法掌握所有研究内容。在研究领域上，任何计算机科学领域，比如操作系统、网络协议，或者任何软硬件，都有其相应的“游戏规则”和“安全威胁”可以被研究。在网络安全中，人类往往是最薄弱的一环，但同时也扮演着重要的角色。就研究风格而言，网络安全的涉及范围从新型攻击和利用技术，对新兴系统或算法的分析，到防御方案、测量分析等等。另一个维度是一篇论文中所使用的研究方法：人工分析、逆向工程、程序分析、形式化方法、基于硬件的系统设计、数据驱动方法，如机器学习和人工智能。找到你喜欢的论文类型将有助于培养你的研究兴趣，最终缩小研究范围并形成一个新的研究思路。&lt;/p&gt;&#xA;&lt;p&gt;在我职业生涯的早期，我沉迷于可以攻破最新防御体系的新型攻击技术。这是创造性的、优雅的、极度让人满足的，并能够发现其他人看不到的安全缺陷。当我读到这样的论文时，我总是问自己：“这些人是如何找到缺陷的？开展这样的研究需要什么技能？”。这种研究风格，在有意或无意间引导我培养出了攻读博士学位所必需的思维定势和各种技能。由于我的导师当时的研究专注点在于网络，所以我很自然地致力于研究网络领域中的安全问题（如TCP安全）。然而，在当时我并没有机会掌握诸如程序分析、形式化方法和机器学习这类过硬的技术。当我即将毕业时，我的研究兴趣开始发生转变，因为我意识到，在解决安全问题方面，如果没有适当的自动化技术，是不可能真正做到可持续或可扩展的。因此，我开始学习程序分析、关于模型检查和机器学习/人工智能方面的知识。这对我个人来说非常有帮助。当然，每个人情况各异，你总能找到自己的兴趣，并以此发展出一条独特的研究之路。其实，这正是学术自由之美！&lt;/p&gt;&#xA;&lt;h2 id=&#34;认清产生研究思路的范式&#34;&gt;认清产生研究思路的范式&lt;/h2&gt;&#xA;&lt;p&gt;每一篇论文背后都有一个独特的故事，但它们产生的方式往往可以归类为几种范式。其中大部分是我从研究经验中提炼出来的，也有一些是从其他研究者那里借鉴得来的。例如，来自加州大学圣地亚哥分校（UCSD）大学的Philip Guo教授有一篇很棒的关于各种研究范式的博客文章，这些范式引起了我的很多共鸣。以下是我所提供的版本，并通过具体的例子加以说明。注意这些范式可能并非完全契合。它们只是一些简单的方式，用来展示一个研究思路是如何产生的。一旦你掌握了其中某几个范式，想出新的研究思路将是小菜一碟（当然，在决定实现这个想法之前，仍然需要对它的价值进行评估）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;范式1填补空白&#34;&gt;范式1：填补空白&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.inforsec.org/wp/wp-content/uploads/2021/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210902113513.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这是我大学期间，在微软的Harry Shum博士关于研究的报告上听到的一个简单的范式。这个想法在概念上其实很简单。读几篇关于某一主题的论文，记下这些论文在系统、方法、技术、数据集等方面提供的前提假设、证明支撑/属性特点等方面的差异，即下面所提到的“维度”，然后画一张表（不一定是二维的）来进行“维度”比较。找到其中的“空白”，即未被考虑或涉足的部分，这些都是潜在的新的研究思路（事实上，许多好的论文使用这样一个表格来清晰地表明自身的研究与相关研究的区别）。&lt;/p&gt;&#xA;&lt;p&gt;以对抗机器学习领域为例，许多研究人员最初关注的是图像。例如，如何扰乱一张猫的照片，使它被错误地识别为香蕉。很快，其他领域诸如视频、音频和恶意软件也被拿来做对抗研究（例如，如何通过注入无意义的指令来欺骗恶意软件分类器）。另一个简单的例子是：研究人员可能已经应用静态分析技术来自动发现某些类型的漏洞，但还没有人应用动态分析技术来做这件事。接下来，你可以调研静态分析与动态分析在发现特定类型漏洞上的优缺点。当然，现实中也存在各种类型的静态分析和动态分析技术。你可以制作一个更为细粒度的表格来发现更多的“空白”部分。同样地，如果你已经对某种特定类型的漏洞进行过研究，还可以对其他不同类型的漏洞进行研究。&lt;/p&gt;&#xA;&lt;p&gt;成功应用此范式的关键是绘制出该对比空间中存在的“维度”。你研究得越深，就越有可能找到可以被研究的“空白”部分。例如，你必须熟悉不同种类的程序分析技术，然后才能绘制出一张表格并确定某个特定的技术并没有被用来解决过某个问题。同样地，你需要了解不同类型的漏洞（仅内存损坏漏洞就有十几种类型）。&lt;/p&gt;&#xA;&lt;p&gt;识别“维度”通常有两种常用的方法。第一种方法，广泛阅读大量论文，寻找类似主题论文之间的差异。相信我，当有一天需要用到相关的论文知识时，这将会很方便。另一种方法，阅读综述文章，因为它们通常已经在多个“维度”上进行了总结梳理。在网络安全领域，IEEE安全与隐私会议（四大安全顶级会议之一）每年以知识体系化（SoK）的形式接收并发表若干篇论文。如果你感兴趣的话，它们绝对值得一读。&lt;/p&gt;&#xA;&lt;h3 id=&#34;范式2扩充延伸&#34;&gt;范式2：扩充延伸&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.inforsec.org/wp/wp-content/uploads/2021/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210902113516.jpg&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这是“填补空白”范式的自然递进。正如上文所提到的，绘制空间中一些好的“维度”可能是最具挑战性的一步。但是，如果你在某个方向已经有了一些研究思路（例如发表了一两篇论文），就可以从特别的角度看到别人不容易找到的“维度”。&lt;/p&gt;&#xA;&lt;p&gt;我们发表在USENIX Security 2016上进行TCP侧信道攻击的论文“Off-Path TCP Exploits：Global Rate Limit Considered Dangerous”（路径外TCP漏洞：全局速率限制是危险的）就是基于这种范式驱动的。我们之前的工作（发表于S&amp;amp;P 2012和CCS 2012），对攻击条件要求非常高（有人可能认为这是不现实的），即假设一个非特权级别的恶意软件已经安装在受害者的智能手机上（或者网络中部署了某种类型的防火墙）。而这篇论文则努力减轻对这样要求苛刻条件的依赖，这也使得我们发现了一个全新的攻击侧信道。实际上，我已经基本绘制出了关于攻击需求的“维度”，即“攻击需求：恶意软件｜防火墙｜无”。&lt;/p&gt;&#xA;&lt;p&gt;我们发表在CCS 2020的论文“DNS Cache Poisoning Attack Reloaded: Revolutions with Side Channels”（重新加载 DNS 缓存中毒攻击：侧信道革命）也属于这一类。这是另一篇侧信道文章，在文中我们将侧信道经验从TCP迁移到UDP，漏洞的利用本质其实是非常相似的。实际上，这两篇文章是在Linux内核实现中寻找TCP/UDP套接字之间的共享资源（即全局变量）。所以这里的“维度”是关于不同类型的网络协议。&lt;/p&gt;</description>
    </item>
    <item>
      <title>莱斯定理</title>
      <link>https://www.snakin.top/posts/risetheorem/</link>
      <pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://www.snakin.top/posts/risetheorem/</guid>
      <description>&lt;p&gt;莱斯定理（Rice’s Theorem） 是计算理论中的一个重要定理，它揭示了所有非平凡的语义属性在图灵完备的编程语言中都不可判定。换句话说，对于任何程序的语义性质，如果该性质不是“平凡”的，那么就无法构造一个通用的算法来决定所有程序是否具有这一性质。&lt;/p&gt;&#xA;&lt;h2 id=&#34;莱斯定理的内容&#34;&gt;莱斯定理的内容&lt;/h2&gt;&#xA;&lt;p&gt;莱斯定理的正式表述如下：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;设P是图灵机程序集合的一个非平凡属性（即，既存在满足该属性的程序，也存在不满足该属性的程序），则不存在一个算法可以决定一个给定的图灵机程序M是否具有属性P 。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;简化来说，莱斯定理指出：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;对于任何非平凡的语义属性，决定一个给定程序是否具有该属性是不可判定的。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;解释&#34;&gt;解释&lt;/h2&gt;&#xA;&lt;p&gt;非平凡属性：属性不是所有程序都满足，也不是所有程序都不满足。例如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;“程序是否会停机？” 是一个非平凡的属性。&lt;/li&gt;&#xA;&lt;li&gt;“程序是否输出 0？” 也是一个非平凡的属性，因为一些程序输出 0，而另一些程序不输出 0。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不可判定性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;莱斯定理告诉我们，无法编写一个通用算法来判定任何给定程序是否具有某个特定的语义属性。换句话说，任何涉及程序的语义特征的通用判定问题都是不可判定的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;举例&#34;&gt;举例&lt;/h2&gt;&#xA;&lt;p&gt;给定一个程序或程序片段，是否存在漏洞？这是一个非平凡的属性，因为：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存在一些程序是安全的（没有漏洞）。&lt;/li&gt;&#xA;&lt;li&gt;存在一些程序是不安全的（有漏洞）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;同时，漏洞是程序行为的一种特定性质，通常涉及程序执行过程中的特定条件（如内存泄漏、缓冲区溢出、SQL注入等）。这些性质通常不能仅通过语法分析（即单纯查看代码的文本结构）来确定，而需要理解程序的语义（即程序在运行时如何表现，执行时的状态如何变化）。&lt;/p&gt;&#xA;&lt;p&gt;根据莱斯定理，由于漏洞检测是一个非平凡的语义属性，所以没有通用算法可以在所有情况下决定任意程序片段是否存在漏洞。因此，漏洞检测是不可判定的。&lt;/p&gt;&#xA;&lt;p&gt;尽管漏洞检测在理论上是不可判定的，但在实际应用中，通常采用启发式方法、静态分析、动态分析和机器学习等技术来检测程序中的潜在漏洞。虽然这些方法不能保证对所有情况都给出正确的答案，但它们在实际场景中仍能有效地发现大量常见的安全问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;莱斯定理的意义&#34;&gt;莱斯定理的意义&lt;/h2&gt;&#xA;&lt;p&gt;莱斯定理的意义在于，它揭示了计算理论中的一个基本限制：在一般情况下，关于程序行为的许多有趣问题都是不可判定的。这一结果在理论计算机科学中非常重要，它限制了我们能用算法解决的问题类型，并指导我们在哪里使用启发式方法或半算法（如静态分析、模型检查等）来近似解决这些问题。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
